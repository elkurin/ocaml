-----問1-----
nat は S (S (S ... (S Z) ... ) と書くこととし、Sが出てくる回数がnatの値とする
例えば 4 = (S (S (S (S Z)))という感じ
加算はaのSの回数分だけbにSを加えている
減算はbがZになるまでaのSを外していき、bがZになったらあとはSの数を数えるだけ
ただ、自然数の減算でため引く数の方が大きい場合はZを返す仕様にした
乗算はa+aをb回するものと考えられるのでaddを利用して再帰
累乗はa*aをb回するものと考えられるのでmulを利用して再帰
n2i, i2nはいずれもSの個数とintの値を対応させるだけ

動作例
# add b c;;
- : nat = S (S (S (S (S (S (S Z))))))
# sub b c;;
- : nat = S Z
# mul b c;;
- : nat = S (S (S (S (S (S (S (S (S (S (S (S Z)))))))))))
# pow b a;;
- : nat = S Z
# n2i S (S (S Z));;
- : int = 3
# i2n 3;;
- : nat = S (S (S Z))


-----問2-----
pre, ino, postがそれぞれ行きがけ順、通りがけ順、帰りがけ順となっている
preが根->左の木->右の木
inoが左の木->根->右の木
postが左の木->右の木->根
postは根->右の木->左の木の逆順で、こうした方がappendの回数が減り、reverseは線形時間なので良い

動作例
# pre a;;
- : int list = [1; 2; 4; 5; 3; 6; 7]
# ino a;;
- : int list = [4; 2; 5; 1; 6; 3; 7]
# post a;;
- : int list = [4; 5; 2; 6; 7; 3; 1]


-----問3-----
level関数でリストを生成する
参照のリストが答えとなる
level関数では、まずqueueに受け取ったtreeのノードをpushし、それを渡してloop関数に入る
loop関数では、queueのtopをとってその要素を参照のリストに追加し、topをpopしたリストにtopの左のノードと右のノードをpushしたものを次のloopに渡す
結果、参照のリストに答えがある
今回は計算量を抑えるため参照で作さえされるリストは逆順になっているので、最後にreverseして返しておわり

動作例
# level a;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9]

-----問4,5-----
問4,5をまとめて4-5.mlに書いた
問4は記されたすべてを列記した
問5ではexceptionにEval_errorを追加しエラー処理をしたときにエラーが返るようにした
またBool演算では、加算減算乗算等式評価をvalidとし割り算と不等号評価はエラーが返るようにした
eval関数の中にすべてを書くと見にくかったので、外部に処理の内容の関数を用意した
evalで返るものは必ずvalue型または例外処理かとなっている
下の方に動作確認用のものが羅列してあるがプログラム自体とは関係ない

動作例は、4-5.mlを実行すれば出てくる



