-----問1-----
1.mlにコードを書いた
nat は S (S (S ... (S Z) ... ) と書くこととし、Sが出てくる回数がnatの値とする
例えば 4 = (S (S (S (S Z)))という感じ
加算はaのSの回数分だけbにSを加えている
減算はbがZになるまでaのSを外していき、bがZになったらあとはSの数を数えるだけ
ただ、自然数の減算でため引く数の方が大きい場合はZを返す仕様にした
乗算はa+aをb回するものと考えられるのでaddを利用して再帰
累乗はa*aをb回するものと考えられるのでmulを利用して再帰
n2i, i2nはいずれもSの個数とintの値を対応させるだけ

動作例
# add b c;;
- : nat = S (S (S (S (S (S (S Z))))))
# sub b c;;
- : nat = S Z
# mul b c;;
- : nat = S (S (S (S (S (S (S (S (S (S (S (S Z)))))))))))
# pow b a;;
- : nat = S Z
# n2i S (S (S Z));;
- : int = 3
# i2n 3;;
- : nat = S (S (S Z))


-----問2-----
2.mlにコードを書いた
pre, ino, postがそれぞれ行きがけ順、通りがけ順、帰りがけ順となっている
preが根->左の木->右の木
inoが左の木->根->右の木
postが左の木->右の木->根
参照を使っても線形で出来るが、今回は 例えば行きがけ順ならf(右, f(左, すでに見た頂点のリスト)) とすることで、答えのリストを作成しながら再帰した
順番はみた順番になっているので、最後にreverseした
帰りがけ順は、右を優先した行き掛け順の逆なので、そう実装すればreverseはなくてもよい（が同じ線形時間なので、今回はわかりやすくすべておなじ形式で書いた)

動作例
# pre a;;
- : int list = [1; 2; 4; 5; 8; 3; 6; 7; 9]
# ino a;;
- : int list = [4; 2; 8; 5; 1; 6; 3; 7; 9]
# post a;;
- : int list = [4; 8; 5; 2; 6; 9; 7; 3; 1]


-----問3-----
3.mlにコードを書いた
解法を3つ作った
解法1
queueを参照を利用して実装した
level関数でリストを生成する
参照だとたくさんのものの値の書き換えが出来ないので、mutable recordを次の宛先に利用した
queueの実装以外は普通にbfsを実装しただけ
計算量は1頂点をちょうど1度ずつ踏むのでO(n)
なお、単純にリストの形でqueueを持ってしまうと、参照などを使わず綺麗に書けるが、queueにpushするのに毎度線形時間かかってしまいO(n^2)となる
(queueの実装の際、"プログラミングinOCaml"の本を参考に使用した)

解法2
参照を利用しない方法を考えた
まずノードとその深さをペアにしたもののリストを作成する
その後にfilterでペアリストの各要素を浅い順に答えリストに入れていき、ある深さのときに追加した要素が存在しなかったらそれ以上深い要素はないので答えリストの作成を停止する
最後に、この答えリストは逆順になっているのでreverseしておわり
計算量は平衡木ではO(nlogn)だが普通の2分木ならO(n^2)となってしまうのであまり良くない

解法3
bunkers queueというデータ構造を活用したもの
参照を使わず、かつO(n)で終わる
queueを半分に割って、左のものは先頭を取り出せる形に、右のものは末尾に追加できる形にして持つ
したがって基本的にpushもpopも定数時間で行える
左側のqueueがからっぽになったら、そのタイミングで右のリストをreverseして左側のqueueとし、右側のリストを空にする
こうすると、ちゃんとqueueの構造を持つ
計算量を考えると、各要素につき、pushとpopとreverse1回のオペレーションを受けることになりつまりそれぞれ各3回しか受けない(reverseは要素数に対して線形時間で終わるので、確かに線形時間でおわる)
("purely functional data structure"のpdfのbankers queueを参考にした)

動作例
# level a;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9]
# level2 a;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9]


-----問4,5-----
問4,5をまとめて4-5.mlに書いた
問4は記されたすべてを列記した
問5ではexceptionにEval_errorを追加しエラー処理をしたときにエラーが返るようにした
またBool演算では、加算減算乗算等式評価をvalidとし割り算と不等号評価はエラーが返るようにした
eval関数の中にすべてを書くと見にくかったので、外部に処理の内容の関数を用意した
evalで返るものは必ずvalue型または例外処理かとなっている
下の方に動作確認用のものが羅列してあるがプログラム自体とは関係ない

動作例は、4-5.mlを実行すれば出てくる


-----発展1-----
6.mlにコードを書いた
(下の方にあるsum_to関数とis_prime関数は、テストのための関係ない関数)

let recが使えないと、関数の中にその関数を書けないのが問題だったが、参照を使うと、返す関数をループの外で定義しておけば値の参照も代入先としても同時に呼べるので、再帰関数を作ることが出来る
参照を利用すると、最初に決めた型がずっと消えないので、例えばint->intの再帰関数を計算したあとに、float->floatの関数を計算するためには、gと異なる参照関数を用意しないといけないことに注意
最初の実装では
let g = (fun x -> x)としていたため、最初のgが'a->'aの型に限定されてしまうので、例えばint->floatみたいな関数は作れなかった
この解決法として、黒魔術を使って'a->'bの関数を無理やり作ってしまう方法があるが、Obj.magicを使うのは良くなさそう
そこで、スライドを確認したら、raise exceptionはまさにa->.bだったのでこれを活用した

動作例
# sum_to 10;;
- : int = 55

-----発展2-----
7.mlにコードを書いた
1-3について
いずれも証明図を書いてからそれを一段ずつ行なう関数を作り、それをまとめた
(_, _)をand_t型と認識してもらうのに、タグがついていればそれを先頭につけるだけでよいが、タグがついていない場合は、and_tの内部の型もしっかり決めないといけないのがむずかしかった

動作は、#use "7.ml"で返ってくる結果を読めば型が正しいことが確認できる

-----発展3-----
8.mlにコードをかいた
fはzの型が特にわからないままなので'a->'bだが、uncurry, curryを通すとfの引数zが'a*'b型に認識されるので、curry (uncurry f) が'a*'b->'cになる
したがって型が異なるので、h fとh (curry (uncurry f))での結果が異なる

実行結果は以下
# h f;;
- : '_a * '_b -> 'c = <fun>
# h (curry (uncurry f));;
- : '_a * '_b -> '_c -> 'd = <fun>

